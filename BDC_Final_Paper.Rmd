---
title: "Big Data Cup"
author: "Quinn MacLean"
date: "4/10/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,warning=FALSE,message=FALSE)

library(tidyverse)
library(gt)
library(ggplot2)
library(grid)
library(png)
library(RCurl)
library(bayesplot)
library(sjPlot)
library(gtsummary)
library(gganimate)
library(reshape2)

### final datasets
defender.sim.mcmc<-read_csv("Summary/defender.sim.mcmc.csv") %>% dplyr::select(-`...1`)

pass.frame.sim.preds<-read_csv("Summary/pass_sim_preds.csv")



pass.success.mod.mcmc<-readRDS("Model/pass.success.mod.mcmc.rds")

pass<-read.csv("Summary/pass.csv")

## sample play - disregard
###sample<-read_csv("sample_tracking.csv")

##### roster data
CAN_USA_roster<-read_csv("Src/TrackingData/2022-02-08 Canada at USA/2022-02-08 Canada at USA roster.csv") %>%
  mutate(team_name = ifelse(team == "away","Canada","USA"))
ROC_FIN_roster<-read_csv("Src/TrackingData/2022-02-08 ROC at Finland/2022-02-08 ROC at Finland roster.csv") %>%
  mutate(team_name = ifelse(team == "away","ROC","Finland"))
SWISS_ROC_roster<-read_csv("Src/TrackingData/2022-02-12 Switzerland at ROC/2022-02-12 Switzerland at ROC roster.csv") %>%
  mutate(team_name = ifelse(team == "away","Switzerland","ROC"))
FIN_USA_roster<-read_csv("Src/TrackingData/2022-02-14 Finland at USA/2022-02-14 Finland at USA roster.csv") %>%
  mutate(team_name = ifelse(team == "away","USA","Finland"))
SWISS_CAN_roster<-read_csv("Src/TrackingData/2022-02-14 Switzerland at Canada/2022-02-14 Switzerland at Canada roster.csv") %>%
  mutate(team_name = ifelse(team == "away","Switzerland","Canada"))
SWISS_FIN_roster<-read_csv("Src/TrackingData/2022-02-16 Switzerland at Finland/2022-02-16 Switzerland at Finland roster.csv") %>%
  mutate(team_name = ifelse(team == "away","Switzerland","Finland"))
roster<-rbind(CAN_USA_roster,ROC_FIN_roster,SWISS_ROC_roster,FIN_USA_roster,SWISS_CAN_roster,SWISS_FIN_roster)

roster<-roster %>%
  dplyr::select(-team) %>%
  distinct()

rm(CAN_USA_roster)
rm(ROC_FIN_roster)
rm(SWISS_ROC_roster)
rm(FIN_USA_roster)
rm(SWISS_CAN_roster)
rm(SWISS_FIN_roster)

pass.frame.sim.preds<-pass.frame.sim.preds %>%
  left_join(roster,by=c("defender_num" = "jn","defender_team" = "team_name")) %>%
  rename("closest_defensive_player" = player,
         "defensive_position" = position.y)

pass_join<-pass %>%
  dplyr::filter(complete.cases(dis_event_des_x_abs)) %>%
  dplyr::select(playId,jn,separation,net_separation,closest_opp_player_separation,
                closest_event_player_separation,dis_event_x_abs,closest_opp_action_separation,
                dis_event_des_x_abs)
  


pass_metrics<-pass.frame.sim.preds %>%
  left_join(pass_join,by=c("playId","jn")) %>%
  group_by(defender_id) %>%
  summarize(n = n_distinct(playId),
            dis_event_x_abs = mean(dis_event_x_abs.y,na.rm=T),
            dis_event_des_x_abs = mean(dis_event_des_x_abs.y,na.rm = T),
            pass_distance = mean(pass_distance,na.rm = T),
            closest_opp_action_separation = mean(closest_opp_action_separation.y,na.rm = T),
            closest_opp_player_separation = mean(closest_opp_player_separation.y,na.rm = T),
            net_separation = mean(net_separation.y,na.rm = T),
            separation = mean(separation.y,na.rm = T)
            )


pass.frame.sim.preds<-pass.frame.sim.preds %>%
  left_join(roster,by=c("defender_num" = "jn","defender_team" = "team_name")) 

############ rink ##################
####################################
### creating a hockey rink with R
###
### plot the right or left half of an
### NHL or IIHF rink using ggplot2
###
### all definitions/coordinates here
### assumed to be relative to the
### center dot at (0, 0)
###
####################################



gg_rink <- function(side = "right", specs = "nhl"){
  
  ### this function uses ggplot's annotate()
  # to draw the rink.
  # I recommend calling this function PRIOR to invoking
  # geoms for data so that the points aren't covered
  # by the annotations
  
  ### inputs:
  #     1. side = which side to plot: "right" (default) or "left"
  #     2. specs = which rink size to use: "nhl" (default) or "iihf" for
  #        international
  
  # check inputs
  side <- tolower(side)
  specs <- tolower(specs)
  stopifnot(side %in% c("right", "left"))
  stopifnot(specs %in% c("nhl", "iihf"))
  
  side <- switch(side,
                 "right" = 1,
                 "left" = -1)
  
  nsteps <- 1001 # line resolution for drawing circles/segments
  circle <- seq(0, 2*pi, length = nsteps) # angles to draw a circle
  
  img <- readPNG("Viz/BigDataCup.png")
  g <- rasterGrob(img, interpolate=TRUE)
  
  switch(specs,
         "nhl" = {
           # NHL specifications
           # all units in feet
           
           ### rink boundaries ###
           ## assumed to be standard 200x85ft dimensions
           x_max <- 100
           y_max <- 42.5
           y_min <- -y_max
           # blue line 75' from end boards
           x_blue <- x_max - 75
           # goal line 11' from end boards
           x_goal <- x_max - 11
           
           ### parameter setup
           ## corners rounded in arc of circle with 28' radius
           r_corner <- 28
           
           ## crease semi-circle
           # 6' radius from center of goal line starting 4.5' out
           crease_end <- 4.5
           r_crease <- 6
           # deepest point of net is 40"
           net_depth <- 40/12
           # crease is 8' long; goal posts 6' apart
           goal_post_start <- 6/2
           crease_start_y <- 8/2
           # inner crease lines begin 4' from goal line
           # extend 5" into crease
           crease_small_start <- 4
           crease_small_length <- 5/12
           
           ## face-off circle dots and lines
           # dot locations: 20' from goal line, 22' in each y direction
           x_dot_dist <- 20
           y_faceoff_dot <- 22
           # face-off circle radius 15'
           r_faceoff <- 15
           # hash marks 2' long, 5'7" apart
           hash_length <- 2
           hash_space <- 67/12
           # circle inner lines:
           # x-direction: lines 4' apart, so start 2' from dot
           # y-direction: lines 18" apart, so start 9" from dot
           inner_start_x <- 2
           inner_start_y <- 1.5/2
           # lines parallel to side boards: 4' long
           par_side_length <- 4
           # lines parallel to end boards: 3' long
           par_end_length <- 3
           
           ## other parameters
           # neutral zone dots are 5' from blue line, 44' apart
           x_dot_neutral <- 5
           # ref circle 5m radius
           r_ref <- 5
           ## trapezoid (NHL only)
           # begins 8' from each goal post
           # bottom base is 28' long
           y_traps_start <- goal_post_start + 8
           y_traps_end <- 14
         },
         "iihf" = {
           # IIHF specifications
           # all units in meters
           
           ### rink boundaries ###
           ## assumed to be standard 60x30m dimensions
           x_max <- 30
           y_max <- 15
           y_min <- -y_max
           # blue line 22.86m from end boards, 30cm wide
           x_blue <- x_max - 22.86
           # goal line 4m from end boards
           x_goal <- x_max - 4
           
           ### parameter setup
           ## corners rounded in arc of circle with 8.5m radius
           r_corner <- 8.5
           
           ## crease semi-circle
           # 183cm radius from center of goal line starting 137cm out
           crease_end <- 1.37
           r_crease <- 1.83
           # deepest point of net is 1.12m
           net_depth <- 1.12
           # crease is 244cm long; goal posts 183.5cm apart
           goal_post_start <- 1.835/2
           crease_start_y <- 2.44/2
           # inner crease lines begin 122cm from goal line
           # extend 13m into crease
           crease_small_start <- 1.22
           crease_small_length <- 0.13
           
           ## face-off circle dots and lines
           # dot locations: 6m from goal line, 7m in each y direction
           x_dot_dist <- 6
           y_faceoff_dot <- 7
           # face-off circle radius 4.5m
           r_faceoff <- 4.5
           # hash marks 60cm long, 170cm apart
           hash_length <- 0.6
           hash_space <- 1.7
           # circle inner lines:
           # x-direction: lines 120cm apart, start 60cm from dot
           # y-direction: lines 45cm apart, so start 22.5cm from dot
           inner_start_x <- 0.6
           inner_start_y <- 0.225
           # lines parallel to side boards: 120cm long
           par_side_length <- 1.2
           # lines parallel to end boards: 90cm long
           par_end_length <- 0.9
           
           ## other parameters
           # neutral zone dots are 1.5m from blue line
           x_dot_neutral <- 1.5
           # ref circle 3m radius
           r_ref <- 3
         }
  )
  
  ## corners
  curve_angle <- seq(pi/2, 0, length = nsteps)
  curve_angle_last <- curve_angle[nsteps]
  # y coord at end of curve to connect ends
  y_curve_end <- (y_max - r_corner) + r_corner*sin(curve_angle_last)
  # for goal line, find y coord when x is at goal line
  goal_angle <- acos(
    (x_goal - (x_max - r_corner))/r_corner
  )
  y_goal <- (y_max - r_corner) + r_corner*sin(goal_angle)
  
  ## crease
  crease_angles <- seq(
    pi - acos(crease_end/r_crease),
    pi + acos(crease_end/r_crease),
    length = nsteps
  )
  
  ## face-off circle
  x_faceoff_dot <- x_goal - x_dot_dist
  # find y coord on circle where hashes begin
  y_hash <- r_faceoff*sin(
    acos((hash_space/2)/r_faceoff)
  )
  
  ### create list of components to pass to ggplot
  list(
    theme_minimal(),
    theme(panel.grid = element_blank()),
    ### blue line
    annotate(
      "segment",
      x = x_blue*side, y = y_max,
      xend = x_blue*side, yend = y_min,
      color = "blue", size = 2
    ),
    ### ref crease
    annotate(
      "path",
      x = r_ref*cos(seq(pi/2, 0, length = nsteps))*side,
      y = y_min + r_ref*sin(seq(pi/2, 0, length = nsteps)),
      color = "red"
    ),
    ### face-off circle, center ice
    annotate(
      "path",
      x = r_faceoff*cos(seq(pi/2, -pi/2, length = nsteps))*side,
      y = r_faceoff*sin(seq(pi/2, -pi/2, length = nsteps)),
      color = "blue"
    ),
    annotation_custom(g, xmin=35, xmax=55, ymin=-20, ymax=20),
    ### center line:
    annotate(
      "segment",
      x = 0, y = y_max,
      xend = 0, yend = y_min,
      color = "red", size = 2
    ),
    switch(specs,
           "nhl" = annotate(
             # dashed white lines atop center line (NHL only)
             "segment",
             x = 0, y = y_max,
             xend = 0, yend = y_min,
             color = "white", size = 0.5, linetype = "dashed"
           ),
           "iihf" = annotate(
             # 50cm space between lines around center dot
             "segment",
             x = 0, y = 0.5,
             xend = 0, yend = -0.5,
             color = "white", size = 2.5
           )
    ),
    ### face-off dot, center ice
    annotate(
      "point",
      x = 0,
      y = 0,
      color = "blue", size = 1
    ),
    ### neutral zone dots
    annotate(
      "point",
      x = (x_blue - x_dot_neutral)*side,
      y = y_faceoff_dot*c(1, -1),
      color = "red", size = 1
    ),
    ### side boards
    annotate(
      "segment",
      x = 0, y = c(y_min, y_max),
      # stop where corner curve begins
      xend = (x_max - r_corner)*side, yend = c(y_min, y_max),
      size = 1
    ),
    ### ends
    # goal line
    annotate(
      "segment",
      x = x_goal*side, y = y_goal,
      xend = x_goal*side, yend = -y_goal,
      color = "red"
    ),
    # connect ends
    annotate(
      "segment",
      x = x_max*side, y = y_curve_end,
      xend = x_max*side, yend = -y_curve_end,
      size = 1
    ),
    # corners rounded in arc of circle
    # starting point: (x_max, y_max) - r_circle from pi/2 to 0
    annotate(
      "path",
      x = ((x_max - r_corner) + r_corner*cos(curve_angle))*side,
      y = (y_max - r_corner) + r_corner*sin(curve_angle),
      size = 1
    ),
    annotate(
      "path",
      x = ((x_max - r_corner) + r_corner*cos(curve_angle))*side,
      y = -((y_max - r_corner) + r_corner*sin(curve_angle)),
      size = 1
    ),
    ### crease
    annotate(
      "segment",
      x = x_goal*side,
      y = crease_start_y*c(-1, 1),
      xend = (x_goal - crease_end)*side,
      yend = crease_start_y*c(-1, 1),
      col = "red"
    ),
    # crease lines
    annotate(
      "segment",
      x = (x_goal - crease_small_start)*side,
      y = crease_start_y*c(-1, 1),
      xend = (x_goal - crease_small_start)*side,
      yend = (crease_start_y - crease_small_length)*c(-1, 1),
      col = "red"
    ),
    # semi-circle starting 137cm out with 183cm radius from center of goal line
    annotate(
      "path",
      x = (x_goal + r_crease*cos(crease_angles))*side,
      y = r_crease*sin(crease_angles),
      col = "red"
    ),
    if (specs == "nhl") {
      ### restricted area (NHL only)
      annotate(
        "segment",
        x = x_goal*side, y = y_traps_start*c(-1, 1),
        xend = x_max*side, yend = y_traps_end*c(-1, 1),
        color = "red"
      )
    },
    ### net
    annotate(
      "segment",
      x = x_goal*side,
      y = goal_post_start*c(-1, 1),
      xend = (x_goal + net_depth)*side,
      yend = goal_post_start*c(-1, 1)
    ),
    annotate(
      "segment",
      x = (x_goal + net_depth)*side,
      y = -goal_post_start,
      xend = (x_goal + net_depth)*side,
      yend = goal_post_start
    ),
    ### face-off circles
    # dot
    annotate(
      "point",
      x = x_faceoff_dot*side,
      y = y_faceoff_dot*c(1, -1),
      col = "red",
      size = 1
    ),
    # circles 
    annotate(
      # top
      "path",
      x = side*(x_faceoff_dot + r_faceoff*cos(circle)),
      y = y_faceoff_dot + r_faceoff*sin(circle),
      col = "red"
    ),
    annotate(
      # bottom
      "path",
      x = side*(x_faceoff_dot + r_faceoff*cos(circle)),
      y = -(y_faceoff_dot + r_faceoff*sin(circle)),
      col = "red"
    ),
    # hashes
    annotate(
      "segment",
      x = side*(
        x_faceoff_dot + (hash_space/2)*rep(c(1, -1), each = 4)
      ),
      y = (y_faceoff_dot + y_hash*c(1, -1))*rep(c(1, 1, -1, -1), times = 2),
      xend = side*(
        x_faceoff_dot + (hash_space/2)*rep(c(1, -1), each = 4)
      ),
      yend = (y_faceoff_dot + (y_hash + hash_length)*c(1, -1))*
        rep(c(1, 1, -1, -1), times = 2),
      col = "red"
    ),
    ## inner lines
    # parallel to side boards
    annotate(
      # parallel to side boards
      "segment",
      x = side*(
        x_faceoff_dot + inner_start_x*rep(c(1, -1), each = 4)
      ),
      y = (y_faceoff_dot + inner_start_y*c(1, -1))*
        rep(c(1, 1, -1, -1), times = 2),
      xend = side*(
        x_faceoff_dot + (inner_start_x + par_side_length)*
          rep(c(1, -1), each = 4)
      ),
      yend = (y_faceoff_dot + inner_start_y*c(1, -1))*
        rep(c(1, 1, -1, -1), times = 2),
      col = "red"
    ),
    annotate(
      # parallel to end boards
      "segment",
      x = side*(
        x_faceoff_dot + inner_start_x*rep(c(1, -1), each = 4)
      ),
      y = (y_faceoff_dot + inner_start_y*c(1, -1))*
        rep(c(1, 1, -1, -1), times = 2),
      xend = side*(
        x_faceoff_dot + inner_start_x*rep(c(1, -1), each = 4)
      ),
      yend = (y_faceoff_dot + (inner_start_y + par_end_length)*c(1, -1))*
        rep(c(1, 1, -1, -1), times = 2),
      col = "red"
    )
  )
}



```

## Introduction
During the Tracking Data Panel at the 2022 Ottawa Hockey Analytics (OTTHAC), measuring defensive performance was posed as the current area of tracking analytics that had the biggest opportunity and the most difficult to solve. Current event metrics take into account discrete events such as takeaways, blocks, etc. but doesn't account for individual player's presence in shifting offensive strategy. The purpose of this paper aims to identify and approximate defensive play performance. To do so, we rely on tracking movement to combine both identified defensive plays or in situations of an unsuccessful offensive play, the closest defensive player to offensive player. This helps to enhance discrete defensive play tracking. By merging the event data time to the approximate time frame of the tracking data, we can gain valuable insight into the movement at start, leading up to, during the event, and after the event. The average separation of 


**Successful Defensive Plays**: 
-Takeaway
-Unsuccessful Pass
-Dump In/Out resulting in change of possession
-Failed Shot attempt
-Unsuccessful Zone Entry
-Puck Recovery resulting in change of possession


Appendix:
[Jonathan Judge from Baseball Prospectus](https://www.baseballprospectus.com/news/article/38289/bayesian-bagging-generate-uncertainty-intervals-catcher-framing-story/) 


## Modelling Approach & Methodology


Wide variability exists in fitting to individuals defenders ability to successful defend a play or not
```{r a1,echo=FALSE,message=FALSE,warning=FALSE}

#gtsummary::tbl_regression(pass.success.mod.mcmc,
#                         broom.mixed::tidyMCMC(pass.success.mod.mcmc)) 


table_sum<-pass.success.mod.mcmc %>%
  broom.mixed::tidyMCMC(
  conf.int = TRUE, conf.level = 0.95,
  estimate.method = "median", conf.method = "HPDinterval"
) %>%
  dplyr::filter(term %in% c('(Intercept)','separation','net_separation','closest_opp_player_separation','closest_event_player_separation',
                            'dis_event_x_abs','dis_event_des_x_abs','sigma','Sigma[defender_id:(Intercept),(Intercept)]')) %>%
  mutate(term = case_when(
    term == "(Intercept)" ~ "Intercept",
    term == "separation" ~ "Separation",
    term == "net_separation" ~ "Net Separation",
    term == "closest_opp_player_separation" ~ "Closest Opposition Player Separation",
    term == "closest_event_player_separation" ~ "Closest Teammate Player Separation",
    term == "dis_event_x_abs" ~ "Absolute x-Distance to Passer/Shooter",
    term == "dis_event_des_x_abs" ~ "Absolute x-Distance to Event Recipient",
    term == "Sigma" ~ "σ",
    term == "Sigma[defender_id:(Intercept),(Intercept)]" ~ "τ00 defender_id",
    TRUE ~ as.character(NA)
  ),
  estimate = round(estimate,2),
  std.error = round(std.error,3),
  conf.low = round(conf.low,2),
  conf.high = round(conf.high,2)
  ) %>%
  rename(
    "CI Low (5%)" = conf.low,
    "CI High (95%)" = conf.high,
    "Std Error" = std.error,
    "Estimates" = estimate,
    "Coefficient" = term 
  )
  

#0.415 * 0.415


table_sum %>%
    gt() %>%
    tab_options(
      column_labels.background.color = "white",
      column_labels.font.weight = "bold",
      table.border.top.width = px(3),
      table.border.top.color = "transparent",
      table.border.bottom.color = "transparent",
      table.border.bottom.width = px(3),
      column_labels.border.top.width = px(3),
      column_labels.border.top.color = "transparent",
      column_labels.border.bottom.width = px(3),
      column_labels.border.bottom.color = "black",
      data_row.padding = px(3),
      source_notes.font.size = 12,
      table.font.size = 12,
      heading.align = "left"
    ) %>%
    opt_table_font(
      font = list(
        google_font("Chivo"),
        default_fonts()
      )
    ) %>%
    tab_header(
      title = md("Play Succcess Model Summary"),
      subtitle = md("Method: Bayesian MCMC GLM Mixed Effects Model | Chains: 5 | 10,000 Iterations")
    ) %>%
  tab_source_note(
    source_note = md("Data for model was centered & scaled")
  ) %>% 
  tab_style(
    style = list(
      cell_fill(color = "#FED8B1")
    ),
    locations = cells_body(
      columns = vars(Coefficient,Estimates,`Std Error`, `CI Low (5%)`,`CI High (95%)`), # not needed if coloring all columns
      rows = 8)
  )



```


### Model Results

```{r a2,echo=FALSE,message=FALSE}

posterior<-as.matrix(pass.success.mod.mcmc)

mcmc_areas(posterior, regex_pars = c("separation","dis"), bw = "SJ",
           rhat = rhat(pass.success.mod.mcmc, regex_pars = c("separation","dis")))

#mcmc_plot(pass.success.mod.mcmc, type = "rank_overlay")


```



```{r a3,echo=FALSE}

#pass.frame.sim.preds %>%
#  group_by(event) %>%
#  dplyr::summarize(
#    n = n_distinct(playId),
#    PDAA = mean(fitted.values - wo_defender,na.rm = T)) %>%
#  pivot_wider(names_from = event,values_from = c(PDAA,n)) 


#add Positve Defended Play Pct

avg<-pass.frame.sim.preds %>%
  dplyr::mutate(DPAA = fitted.values - wo_defender,
                Pos_DPAA = ifelse(DPAA > 0,playId,NA)) %>%
  dplyr::select(playId,x_coord,y_coord,x_coord_2,y_coord_2,DPAA,event,Pos_DPAA) %>%
  group_by(event) %>%
  summarize(
            `Event Count` = n_distinct(playId),
            DPAA = round(mean(DPAA,na.rm = T),3),
           `Positive Defended Plays` = n_distinct(Pos_DPAA),
           `Positive Defended Plays %` = round(n_distinct(Pos_DPAA) / n_distinct(playId),2)) %>%
  distinct() %>%
  ungroup() %>%
  arrange(DPAA)

avg %>%
    gt() %>%
  fmt_percent(
    columns = c(`Positive Defended Plays %`),
                decimals = 0
  ) %>%
    tab_options(
      column_labels.background.color = "white",
      column_labels.font.weight = "bold",
      table.border.top.width = px(3),
      table.border.top.color = "transparent",
      table.border.bottom.color = "transparent",
      table.border.bottom.width = px(3),
      column_labels.border.top.width = px(3),
      column_labels.border.top.color = "transparent",
      column_labels.border.bottom.width = px(3),
      column_labels.border.bottom.color = "black",
      data_row.padding = px(3),
      source_notes.font.size = 12,
      table.font.size = 12,
      heading.align = "left"
    ) %>%
    opt_table_font(
      font = list(
        google_font("Chivo"),
        default_fonts()
      )
    ) %>%
    tab_header(
      title = md("DPAA Avg by Event"),
      subtitle = md("DPAA:  Defended Plays Above Average | Positively Defended Plays are DPAA > 0")
    ) %>%
  tab_source_note(
    source_note = md("Play is a Passing Play")
  )


  

```


### Tournament Performance




for positive plays & non positive plays

```{r a4, echo=FALSE,message=FALSE,warning=FALSE}

pass_plays<-pass.frame.sim.preds %>%
  mutate(Pass_PDAA = ifelse(event == "Play",fitted.values - wo_defender,NA),
         Pass = ifelse(event == "Play",playId,NA)) %>%
  group_by(defender_id) %>%
  summarize(
    Pass_PDAA = mean(Pass_PDAA,na.rm = T),
    Pass = n_distinct(Pass),
    Pass = ifelse(is.na(Pass_PDAA),0,Pass),
    Pass_PDAA = ifelse(is.na(Pass_PDAA),NA,Pass_PDAA))
  


tab_data<- defender.sim.mcmc %>%
  left_join(pass_metrics,by=c("defender_id")) %>%
  left_join(pass_plays,by=c("defender_id")) %>%
  mutate(mcmc.mean = round(mcmc.mean,3),
         sim.mean = round(sim.mean,3),
         mcmc.sd = round(mcmc.sd,3),
         sim.sd = round(sim.sd,3),
         dis_event_x_abs = round(abs(dis_event_x_abs),2),
         dis_event_des_x_abs = round(abs(dis_event_des_x_abs),2),
         closest_opp_action_separation = round(abs(closest_opp_action_separation),2),
         closest_opp_player_separation = round(abs(closest_opp_player_separation),2),
         net_separation = round(abs(net_separation),2),
         pass_distance = round(abs(pass_distance),2),
         Pass_PDAA = round(Pass_PDAA,3),
         flag_url = case_when(
           defender_team == "ROC" ~ "https://stillmed.olympics.com/media/Images/OlympicOrg/Countries/R/Russian_Federation/CNO-RUS.jpg",
           defender_team == "Switzerland" ~
             "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f3/Flag_of_Switzerland.svg/170px-Flag_of_Switzerland.svg.png",
           TRUE ~ flag_url
         )) %>%
  arrange(desc(mcmc.mean)) %>%
  filter(
         mcmc.mean > 0,
         n > 5) %>%
  ungroup() %>%
  head(5L) %>%
  dplyr::select(closest_defensive_player,position,flag_url,headshot_url,n,mcmc.mean,mcmc.sd,sim.mean,sim.sd,chances,closest_opp_player_separation,Pass,Pass_PDAA)
### figure out pass play event under average

##### top passing defended above average ####
tab_function <- function(data, ...){
  data %>% 
    gt() %>% 
    text_transform(
      locations = cells_body(vars(headshot_url)),
      fn = function(x){
        web_image(
          url = x,
          height = 40
        )
      }
    ) %>% 
    text_transform(
      locations = cells_body(vars(flag_url)),
      fn = function(x){
        web_image(
          url = x,
          height = 20
        )
      }
    ) %>%
    cols_width(vars(flag_url) ~ px(30),
               vars(headshot_url) ~ px(50)) %>%
    cols_label(
      headshot_url = "",
      flag_url = "",
      closest_defensive_player = "Player",
      position = "Pos.",
      chances = "Off. Players Guarding",
      n = "Plays",
      mcmc.mean = "DPAA",
      mcmc.sd = "DPAA Sdev",
      sim.mean = "DPAA (Sim Posteriors)",
      sim.sd = "DPAA Sdev (Sim Posteriors)",
      closest_opp_player_separation = "Avg. Separation to Closest Player (m)",
      Pass = "Pass Plays",
      Pass_PDAA = "DPAA (Passing Plays)"
    ) %>% 
    data_color(
      columns = vars(mcmc.mean),
      colors = scales::col_numeric(
        palette = c("#f7f7f7","#7fbf7b"),         
        domain = NULL
      )
    ) %>% 
    tab_style(
      style = cell_text(weight = "bold"),
      locations = cells_body(
        columns = vars(closest_defensive_player,position)
      )
    ) %>% 
    tab_options(
      column_labels.background.color = "white",
      column_labels.font.weight = "bold",
      table.border.top.width = px(3),
      table.border.top.color = "transparent",
      table.border.bottom.color = "transparent",
      table.border.bottom.width = px(3),
      column_labels.border.top.width = px(3),
      column_labels.border.top.color = "transparent",
      column_labels.border.bottom.width = px(3),
      column_labels.border.bottom.color = "black",
      data_row.padding = px(3),
      source_notes.font.size = 12,
      table.font.size = 12,
      heading.align = "left",
      ...
    ) %>%
    opt_table_font(
      font = list(
        google_font("Chivo"),
        default_fonts()
      )
    )  %>%
    tab_footnote(
      footnote = "Plays include passes, takeaways, dump in/outs, zone entries,shots, puck recoveries (Avg. 8 plays per defender in overall dataset)",
      locations = cells_column_labels(
        columns = n
      )) %>%
    tab_footnote(
      footnote = "DPAA uses 5 MCMC chains",
      locations = cells_column_labels(
        columns = mcmc.mean
      )) %>%
    tab_footnote(
      footnote = "standard deviations for DPAA",
      locations = cells_column_labels(
        columns = mcmc.sd
      ))  %>%
    tab_footnote(
      footnote = "Mean simulation of Posteriors using 10,000 simulations",
      locations = cells_column_labels(
        columns = sim.mean
      ))  %>%
    tab_footnote(
      footnote = "Standard deviation of simulation of Posteriors using 10,000 simulations",
      locations = cells_column_labels(
        columns = sim.sd
      ))  %>%
    tab_header(
      title = md("Top Defending Plays Above Average"),
    subtitle = md("Data: Stathletes | Int'l Games: 2022 Winter Olympics  | Min. 5 Plays defended; DPAA > 0")
  ) %>%
  fmt_missing(
    columns = everything(),
    missing_text = "No Plays"
  )
}

a<-tab_data %>% 
  dplyr::filter(complete.cases(headshot_url)) %>%
  slice(1:10) %>% 
  tab_function()

a



```


Not listing passing plays, given a majority of the plays defender here were passing plays
```{r a5,echo=FALSE,message=FALSE,warning=FALSE}




bot_tab_data<- defender.sim.mcmc %>%
  left_join(pass_metrics,by=c("defender_id")) %>%
    left_join(pass_plays,by=c("defender_id")) %>%
  mutate(mcmc.mean = round(mcmc.mean,3),
         sim.mean = round(sim.mean,3),
         mcmc.sd = round(mcmc.sd,3),
         sim.sd = round(sim.sd,3),
         dis_event_x_abs = round(abs(dis_event_x_abs),2),
         dis_event_des_x_abs = round(abs(dis_event_des_x_abs),2),
         closest_opp_action_separation = round(abs(closest_opp_action_separation),2),
         closest_opp_player_separation = round(abs(closest_opp_player_separation),2),
      Pass_PDAA = round(Pass_PDAA,3),
               flag_url = case_when(
           defender_team == "ROC" ~ "https://stillmed.olympics.com/media/Images/OlympicOrg/Countries/R/Russian_Federation/CNO-RUS.jpg",
           defender_team == "Switzerland" ~
             "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f3/Flag_of_Switzerland.svg/170px-Flag_of_Switzerland.svg.png",
           TRUE ~ flag_url)) %>%
  arrange(mcmc.mean) %>%
  filter(n > 5,
         mcmc.mean < 0,
         complete.cases(closest_defensive_player)) %>%
  ungroup() %>%
  head(5L) %>%
  dplyr::select(closest_defensive_player,position,headshot_url,flag_url,n,mcmc.mean,mcmc.sd,sim.mean,sim.sd,chances,closest_opp_player_separation)


bot_tab_function <- function(data, ...){
  data %>% 
    gt() %>% 
    text_transform(
      locations = cells_body(vars(headshot_url)),
      fn = function(x){
        web_image(
          url = x,
          height = 40
        )
      }
    ) %>% 
    text_transform(
      locations = cells_body(vars(flag_url)),
      fn = function(x){
        web_image(
          url = x,
          height = 20
        )
      }
    ) %>%
    cols_width(vars(flag_url) ~ px(30),
               vars(headshot_url) ~ px(50)) %>%
    cols_label(
      headshot_url = "",
      flag_url = "",
      closest_defensive_player = "Player",
      position = "Pos.",
      chances = "Off. Players Guarding",
      n = "Passes",
      mcmc.mean = "DPAA",
      mcmc.sd = "DPAA Sdev",
      sim.mean = "DPAA (Sim Posteriors)",
      sim.sd = "DPAA Sdev (Sim Posteriors)",
      closest_opp_player_separation = "Avg. Separation to Closest Player (m)"
    ) %>% 
    data_color(
      columns = vars(mcmc.mean),
      colors = scales::col_numeric(
        palette = c("#ee8181","#f7c9c9"),         
        domain = NULL
      )
    ) %>% 
    tab_style(
      style = cell_text(weight = "bold"),
      locations = cells_body(
        columns = vars(closest_defensive_player,position)
      )
    ) %>% 
    tab_options(
      column_labels.background.color = "white",
      column_labels.font.weight = "bold",
      table.border.top.width = px(3),
      table.border.top.color = "transparent",
      table.border.bottom.color = "transparent",
      table.border.bottom.width = px(3),
      column_labels.border.top.width = px(3),
      column_labels.border.top.color = "transparent",
      column_labels.border.bottom.width = px(3),
      column_labels.border.bottom.color = "black",
      data_row.padding = px(3),
      source_notes.font.size = 12,
      table.font.size = 12,
      heading.align = "left",
      ...
    ) %>%
    opt_table_font(
      font = list(
        google_font("Chivo"),
        default_fonts()
      )
    )  %>%
    tab_footnote(
      footnote = "Plays include passes, takeaways, dump in/outs, zone entries,shots, puck recoveries (Avg. Player had 8 plays apart of)",
      locations = cells_column_labels(
        columns = n
      )) %>%
    tab_footnote(
      footnote = "DPAA uses 5 MCMC chains",
      locations = cells_column_labels(
        columns = mcmc.mean
      )) %>%
    tab_footnote(
      footnote = "standard deviations for DPAA",
      locations = cells_column_labels(
        columns = mcmc.sd
      ))  %>%
    tab_footnote(
      footnote = "Simulation of Posteriors using 10,000 simulations",
      locations = cells_column_labels(
        columns = sim.mean
      ))  %>%
    tab_header(
      title = md("Bottom Defending Plays Above Average"),
      subtitle = md("Data: Stathletes | Int'l Games: 2022 Winter Olympics  | Min. 5 Plays defended; DPAA < 0")
    ) %>%
  fmt_missing(
    columns = everything(),
    missing_text = "No Plays"
  )
}




bot_tab_data %>%
bot_tab_function()

```

```{r a6,echo=FALSE,message=FALSE,warning=FALSE}

plot_df<-pass.frame.sim.preds %>%
  dplyr::filter(closest_defensive_player %in% c(
    "Viivi Vainikka",
    "Megan Keller",
    "Minnamari Tuominen",
    "Abby Roque",
    "Yekaterina Dobrodeyeva"
  )) %>%
  dplyr::mutate(DPAA = fitted.values - wo_defender) %>%
  dplyr::select(playId,closest_defensive_player,x_coord,y_coord,x_coord_2,y_coord_2,DPAA,event,event_successful) %>%
  group_by(playId,closest_defensive_player,event,event_successful) %>%
  summarize(x_coord = mean(x_coord,na.rm = T),
            y_coord = mean(y_coord,na.rm = T),
            x_coord = ifelse(x_coord > 100,200-x_coord,x_coord),
            y_coord = y_coord - 45,
            x_coord = ifelse(x_coord > 90,x_coord - 5,x_coord),
            y_coord = ifelse(y_coord > 30,y_coord - 5,y_coord),
            DPAA = as.numeric(as.character(mean(DPAA,na.rm = T))),
            DPAA = abs(DPAA)) %>%
  distinct() %>%
  ungroup() %>%
  arrange(match(closest_defensive_player,c( 
    "Viivi Vainikka",
    "Megan Keller",
    "Minnamari Tuominen",
    "Abby Roque",
    "Yekaterina Dobrodeyeva"
    )))
  
neworder<-c(     
    "Viivi Vainikka",
    "Megan Keller",
    "Minnamari Tuominen",
    "Abby Roque",
    "Yekaterina Dobrodeyeva"
  )
#img_AV<-readPNG(getURLContent('https://upload.wikimedia.org/wikipedia/commons/thumb/b/bc/Flag_of_Finland.svg/640px-Flag_of_Finland.svg.png'))

new_plot<-plot_df
new_plot$group<-factor(new_plot$closest_defensive_player,
                       levels=c(    
    "Viivi Vainikka",
    "Megan Keller",
    "Minnamari Tuominen",
    "Abby Roque",
    "Yekaterina Dobrodeyeva"
    ))

#melt_df<-melt(new_plot,id.vars=c("x_coord","y_coord"),measure.vars = c("DPAA"))

#names(melt_df)<-c("x_coord","y_coord","NA","DPAA")

#melt_df$x_coord <- as.numeric(melt_df$x_coord)
#melt_df$y_coord <- as.numeric(melt_df$y_coord)

#melt_df<-melt_df %>%
#  left_join(new_plot,by=c("x_coord","y_coord","DPAA"))


new_plot$DPAA_group<-cut(new_plot$DPAA,c(-5,-0.2,-0.15,-0.1,-0.05,0,0.05,0.1,0.15,0.2,0.5))

#melt_df$Fill <- cut(melt_df$DPAA, breaks = quantile(melt_df$DPAA, 0:4/4, na.rm = T), 
#                              labels = c(round(quantile(melt_df$DPAA, 0:4/4, na.rm = T), 2)[1:4]), include.lowest = T)



#new_plot %>%
ggplot(data = new_plot,aes(x=x_coord,y=y_coord)) +
  geom_point(aes(x=x_coord,y=y_coord,size = DPAA),color="blue",alpha=.4) +
  gg_rink(side='right') +
  stat_density2d(aes(fill = ..level..,alpha=..level..),
                 size = 2, bins = 5,geom="polygon",show.legend =F) +
  facet_wrap(~group,ncol=2) +
  scale_fill_distiller(direction=-1) +
    scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_void() +
  theme(panel.grid = element_blank(),
        axis.line = element_line(),
        axis.ticks=  element_blank(),
        axis.text = element_blank(),
        plot.title = element_text(hjust = .5,size=14,margin=margin(5,0,10,0)),
        plot.subtitle = element_text(hjust = .5,size=10,margin=margin(0,0,15,0)),
        legend.position = "top",
        panel.spacing.x = unit(1,"lines")
        )+
  guides(alpha = "none",
         color = guide_legend(override.aes = list(fill = NA))
         ) +
  labs(x = "",
       y = "",
       title = "Top 5 Penalty Defenders ",
       subtitle = "Positioning of Plays Made") 








```

Game Notes: 
USA outshot Canada 53-27, although Brianne Jenner scored on the power play, USA held scoreless on their first power play. Canada also scored on a power play. USA had a 6-4 advantage but remained unable to score. In essense, US weren't able to capitalize on power play and Canada's below average defense (credit to great goaltending)k

```{r a7,echo=FALSE,message=FALSE,warning=FALSE}


### breakdown of best player for passing given lowest number



play_plot_df<-pass.frame.sim.preds %>%
  dplyr::mutate(DPAA = fitted.values - wo_defender) %>%
  dplyr::select(playId,closest_defensive_player,DPAA,defender_team,event,pp_index) %>%
  mutate(pos_play = ifelse(DPAA > 0 & event == "Play",playId,NA),
         play = ifelse(event == "Play",playId,NA),
        total_pos = ifelse(DPAA > 0,playId,NA),
    flag_url = case_when(
    defender_team == "USA" ~ "https://upload.wikimedia.org/wikipedia/en/thumb/a/a4/Flag_of_the_United_States.svg/1200px-Flag_of_the_United_States.svg.png",
    defender_team == "Finland" ~ "https://upload.wikimedia.org/wikipedia/commons/thumb/b/bc/Flag_of_Finland.svg/640px-Flag_of_Finland.svg.png",
    defender_team == "ROC" ~ "https://stillmed.olympics.com/media/Images/OlympicOrg/Countries/R/Russian_Federation/CNO-RUS.jpg",
    defender_team == "Switzerland" ~ "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f3/Flag_of_Switzerland.svg/170px-Flag_of_Switzerland.svg.png",
    defender_team == "Canada" ~ "https://upload.wikimedia.org/wikipedia/en/thumb/c/cf/Flag_of_Canada.svg/1200px-Flag_of_Canada.svg.png",
    TRUE ~ as.character(NA)
  )) %>%
  group_by(defender_team,flag_url) %>%
  summarize(
    n = n_distinct(playId),
    power_plays = n_distinct(pp_index),
    total_pos = n_distinct(total_pos),
    play = n_distinct(play),
    pos_play = n_distinct(pos_play),
    DPAA = round(as.numeric(as.character(mean(DPAA,na.rm = T))),3)) %>%
  distinct() %>%
  ungroup() %>%
  mutate(
    DPAAPct = round(total_pos / n,2),
    DPAA_Pass_Pct = round(pos_play / play,2)
  ) %>%
  arrange(desc(DPAA)) %>%
  dplyr::select(defender_team,flag_url,DPAA,power_plays,n,total_pos,DPAAPct,play,pos_play,DPAA_Pass_Pct)
  
####### create GT Table
team_function <- function(data, ...){
  data %>% 
    gt() %>% 
    text_transform(
      locations = cells_body(vars(flag_url)),
      fn = function(x){
        web_image(
          url = x,
          height = px(30)
        )
      }
    ) %>%
    cols_label(
      flag_url = "",
      defender_team = "Defender Team",
      n = "Defending Plays",
      power_plays = "Power Plays",
      total_pos = "Positively Defended Plays",
      DPAAPct = "Positively Defended Plays Pct",
      play = "Passes",
      pos_play = "Positively Defended Passes",
      DPAA = "Avg. DPAA",
      DPAA_Pass_Pct = "Positively Defended Passing Plays Pct"
    ) %>% 
   data_color(
      columns = vars(DPAA),
      colors = scales::col_numeric(
        palette = c("#f7c9c9","#f7f7f7","#7fbf7b"),         
        domain = NULL
      )
    ) %>% 
    tab_style(
      style = cell_text(weight = "bold"),
      locations = cells_body(
        columns = vars(defender_team)
      )
    ) %>% 
    tab_options(
      column_labels.background.color = "white",
      column_labels.font.weight = "bold",
      table.border.top.width = px(3),
      table.border.top.color = "transparent",
      table.border.bottom.color = "transparent",
      table.border.bottom.width = px(3),
      column_labels.border.top.width = px(3),
      column_labels.border.top.color = "transparent",
      column_labels.border.bottom.width = px(3),
      column_labels.border.bottom.color = "black",
      data_row.padding = px(3),
      source_notes.font.size = 12,
      table.font.size = 12,
      heading.align = "left",
      ...
    ) %>%
    opt_table_font(
      font = list(
        google_font("Chivo"),
        default_fonts()
      )
    )  %>%
    tab_header(
      title = md("Defended Above Average by Team Play"),
      subtitle = md("Data: Stathletes | Int'l Games: 2022 Winter Olympics")
    ) 
}


play_plot_df %>%
  team_function()


```




### Other IDeas
Show where defended passing plays were at by country? 



References: 

https://www.baseballprospectus.com/leaderboards/catching/

https://www.baseballprospectus.com/news/article/38289/bayesian-bagging-generate-uncertainty-intervals-catcher-framing-story/

https://github.com/mtthwastn/statswithmatt/blob/master/hockey-with-r/gg-rink.R

https://www.iihf.com/en/events/2022/olympic-w/schedule

https://github.com/mtthwastn/statswithmatt/blob/master/hockey-with-r/gg-rink.R



